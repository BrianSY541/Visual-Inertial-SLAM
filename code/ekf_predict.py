import numpy as np
from pr3_utils import *

def ekf_predict(T_prev, P_prev, v, w, dt, Q):
    """
    EKF Prediction step: Update the pose and covariance based on SE(3) kinematics and IMU measurements.
    
    Inputs:
        T_prev: 4x4 numpy array, previous timestep pose (SE(3))
        P_prev: 6x6 numpy array, previous timestep state error covariance
        v: (3,) numpy array, linear velocity from IMU (in the IMU frame) at the current timestep
        w: (3,) numpy array, angular velocity from IMU (in the IMU frame) at the current timestep
        dt: float, time interval for the current timestep
        Q: 6x6 numpy array, process noise covariance matrix
    Outputs:
        T_pred: 4x4 numpy array, predicted pose
        P_pred: 6x6 numpy array, predicted state error covariance
    """
    # Create a twist vector (translation, rotation) by multiplying by dt for discretization
    u = np.concatenate([v * dt, w * dt])  # shape (6,)

    # Compute the incremental pose using the exponential map:
    # axangle2pose expects an input shape of (n,6) and returns an (n,4,4) SE(3) matrix.
    delta_T = axangle2pose(u[np.newaxis, :])[0]  # obtain the 4x4 incremental transformation matrix

    # Pose prediction: Right multiply by the incremental transformation
    T_pred = T_prev @ delta_T

    # Error propagation: compute the corresponding linearized matrix
    # First, compute the ad(se(3)) matrix generated by the twist u, using a first-order approximation.
    A = axangle2adtwist(u[np.newaxis, :])[0]  # 6x6 matrix
    F = np.eye(6) - A  # State transition matrix (first-order approximation)

    # Assume the noise Jacobian is dt times the identity matrix
    G = dt * np.eye(6)

    # Update the error covariance
    P_pred = F @ P_prev @ F.T + G @ Q @ G.T

    return T_pred, P_pred

def predict_trajectory(v_t, w_t, timestamps, Q):
    """
    Compute the full predicted trajectory using EKF prediction based on all IMU measurements.
    
    Inputs:
        v_t: numpy array of shape (T, 3), linear velocity measurements at each timestep
        w_t: numpy array of shape (T, 3), angular velocity measurements at each timestep
        timestamps: numpy array of shape (T,), timestamps in seconds
        Q: 6x6 numpy array, process noise covariance matrix
    Outputs:
        trajectory: numpy array of shape (T, 4, 4), pose (SE(3)) at each timestep
        covariances: list, each element is a 6x6 state error covariance matrix
    """
    # Initial pose is set to the identity matrix; the initial covariance can be set to zero or a small positive value (adjust as needed)
    T0 = np.eye(4)
    P0 = np.zeros((6, 6))

    trajectory = [T0]
    covariances = [P0]

    T_current = T0
    P_current = P0

    # Sequentially update starting from the second timestep
    for i in range(1, len(timestamps)):
        dt = timestamps[i] - timestamps[i - 1]
        # Use the IMU measurements from the previous timestep to predict the next timestep.
        v = v_t[i - 1]
        w = w_t[i - 1]

        T_current, P_current = ekf_predict(T_current, P_current, v, w, dt, Q)
        trajectory.append(T_current)
        covariances.append(P_current)

    trajectory = np.array(trajectory)  # Convert to a numpy array of shape (T, 4, 4)
    return trajectory, covariances

if __name__ == '__main__':
    # Load data (iterate over 3 datasets, 00, 01 & 02)
    datanum = ['00', '01', '02']
    for i in datanum:
        filename = f"../data/dataset{i}/dataset{i}.npy"
        v_t, w_t, timestamps, features, K_l, K_r, extL_T_imu, extR_T_imu = load_data(filename)
        
        # Set the process noise covariance Q; adjust parameters as needed
        sigma_v = 0.1       # Standard deviation for linear velocity (m/s)
        sigma_w = 0.01745   # Standard deviation for angular velocity (rad/s), approximately 1Â° in radians
        Q_default = np.diag([sigma_v**2, sigma_v**2, sigma_v**2,
                             sigma_w**2, sigma_w**2, sigma_w**2])
        
        # Compute the IMU trajectory and the error covariance at each timestep using EKF prediction
        trajectory, covariances = predict_trajectory(v_t, w_t, timestamps, Q_default)
        
        # Plot the x-y plane trajectory (with orientation arrows) using the provided function
        fig, ax = visualize_trajectory_2d(trajectory, path_name="IMU trajectory",show_ori=True)
        ax.set_title(f"IMU Trajectory via EKF Prediction for dataset{i}")
        plt.show()
